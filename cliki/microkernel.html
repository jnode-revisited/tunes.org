<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML><HEAD><TITLE>CTO : Microkernel</TITLE
><LINK REL="alternate" TYPE="application/rss+xml" TITLE="Recent Changes" HREF="/tunes.org/cliki/recent-changes.rdf.html"><LINK REL="stylesheet" HREF="admin/cliki.css"></HEAD
><BODY><DIV ID="banner"><A TITLE="CTO" CLASS="logo" HREF="microkernel.html">CTO</A
> <SPAN>CLiki for the TUNES project</SPAN
></DIV
><DIV ID="navbar"><A CLASS="internal" HREF="index.html">Home</A
>  <A CLASS="internal" HREF="cliki.html">About CLiki</A
> <A CLASS="internal" HREF="text_20formatting.html">Text Formatting</A
> </DIV
><DIV ID="main"><H1>Microkernel</H1
>Microkernel (also abbreviated �K or uK) is the <a class="internal" href="term.html" >term</a> describing an approach to <a class="internal" href="operating_20system.html" >Operating System</a> design by which the functionality of the system is moved out of the traditional "<a class="internal" href="kernel.html" >kernel</a>", into a set of "<a class="internal" href="server.html" >server</a>s" that communicate through a "minimal" <a class="internal" href="kernel.html" >kernel</a>, leaving as little as possible in "system space" and as much as possible in "<a class="internal" href="user.html" >user</a> space".

<p>See also <a class="internal" href="microkernel_20debate.html" >Microkernel Debate</a>.

<p><h2>Rationale</h2>

<p>Microkernels were invented as a reaction to traditional "monolithic" <a class="internal" href="kernel.html" >kernel</a> design, whereby all system functionality was put in a one static program running in a special "system" mode of the processor. The rationale was that it would bring modularity in the system architecture, which would entail a cleaner system, easier to debug or dynamically modify, customizable to <a class="internal" href="user.html" >user</a>s' needs, and more performant.

<p><h2>Examples</h2>

<p>Perhaps the best known example of microkernel design is <a class="internal" href="mach.html" >Mach</a>, originally developed at CMU, and used in some free and some proprietary <a class="internal" href="bsd.html" >BSD</a> <a class="internal" href="unix.html" >Unix</a> derivatives, as well as in the heart of <a class="internal" href="gnu.html" >GNU</a> <a class="internal" href="hurd.html" >HURD</a>. Rumor had it <a class="internal" href="microsoft_20windows.html" ><tt>MICROS~1</tt> Windows NT</a> would originally have been a microkernel design (that was grown into the bloated thing it is), but this has been denied by <a class="internal" href="microsoft_20windows.html" >NT</a> architect Dave Cutler. Other well-known microkernels include <a class="internal" href="chorus.html" >Chorus</a>, <a class="internal" href="qnx.html" >QNX</a>, <a class="internal" href="vsta.html" >VSTa</a>, etc. Latest evolutions in microkernel design led to things like "nano-<a class="internal" href="kernel.html" >kernel</a>" <a class="internal" href="l4.html" >L4</a>, or "exokernel" <a class="internal" href="xok.html" >Xok</a>, where the <a class="internal" href="kernel.html" >kernel</a> is shrunk ever more towards less functionality and less portability.

<p><h2>Opinionated History</h2>

<p>At one time in the late 1980's and early 1990's, microkernels were the craze in official academic and industrial <a class="internal" href="os.html" >OS</a> design, and anyone not submitting to the dogma was regarded as ridiculous (at least it seems to me from reading articles from <a class="internal" href="os.html" >OS</a> conferences, or the <a class="internal" href="minix.html" >Minix</a> vs <a class="internal" href="linux.html" >Linux</a> flamefest; could people help confirm or infirm this impression of mine?). But microkernels failed to deliver their too many promises in terms of either modularity, cleanliness, ease of debugging, ease of dynamic modification, customizability, or performance. This led some microkernel people to compromise by having "single-<a class="internal" href="server.html" >server</a>s" that have all the functionality, and pushing them inside <a class="internal" href="kernel.html" >kernel</a>-space (allegedly <a class="internal" href="microsoft_20windows.html" >NT</a>, hacked <a class="internal" href="mklinux.html" >MkLinux</a>), yielding a usual monolithic <a class="internal" href="kernel.html" >kernel</a> under another name and with a contorted design. Other microkernel people instead took an even more radical view of stripping the <a class="internal" href="kernel.html" >kernel</a> from everything but the most basic system-dependent interrupt handling and messaging capabilities, and having the rest of system functionality in libraries of system or <a class="internal" href="user.html" >user</a> code, which again is not very different from monolithic systems like <a class="internal" href="linux.html" >Linux</a> that have well-delimited architecture-specific parts separated from the main body of portable code. With the rise of <a class="internal" href="linux.html" >Linux</a>, and the possibility to benchmark monolithic versus microkernel variants thereof, as well as the possibility to compare <a class="internal" href="kernel.html" >kernel</a> development in various open monolithic and microkernel systems. People were forced to acknowledge the practical superiority of "monolithic" design according to all testable criteria. Nowadays, microkernel is still the "official" way to design an <a class="internal" href="os.html" >OS</a>, although you wont be laughed at when you show your monolithic <a class="internal" href="kernel.html" >kernel</a> anymore. The sad truth about Microkernels has been known <a href="http://www.netfunny.com/rhf/jokes/90q4/mfraud.html">for a long time</a>, but as far as we know, no one in the academic world ever dared raise any public theoretical criticism of the very concept of microkernel. Instead, any attempt to analyze things rationally will be dismissed as tackling an "obsolete" problem, including any attempt to assess whether the problem is indeed obsolete.

<p><h2>Argumented Criticism</h2>

<p>As people understood that <a class="internal" href="kernel.html" >kernel</a>s only introduce (design-time and run-time) overhead without adding any functionality that couldn't be better achieved without it (for several reasons like efficiency, maintainability, modularity, etc), they tried to reduce <a class="internal" href="kernel.html" >kernel</a> sizes as much as they could. The result is called a microkernel, which is pure overhead, with no functionality at all. There has thus been a (now waning) craze in <a class="internal" href="operating_20system.html" >Operating System</a> research and development to boast about using a microkernel. 

<p>I contend that microkernels are a deeply flawed idea: instead of removing the <a class="internal" href="overhead.html" >overhead</a>, they concentrate and multiply it. The overall space/time cost of the <a class="internal" href="os.html" >OS</a> is not reduced at all, as the functionality has only been moved away from the <a class="internal" href="kernel.html" >kernel</a> into "<a class="internal" href="server.html" >server</a>s"; only now there is an additional overhead in space as well as in time and as in design, to manage the information flow of system services that now needs to go from <a class="internal" href="user.html" >user</a> to <a class="internal" href="kernel.html" >kernel</a> then <a class="internal" href="kernel.html" >kernel</a> to <a class="internal" href="server.html" >server</a>. Because of the low <a class="internal" href="abstraction_20level.html" >abstraction level</a> of microkernels, lots of <a class="internal" href="low-level.html" >low-level</a> bindings must be done for "<a class="internal" href="server.html" >server</a>s" that provide functionality, so nothing is gained at the <a class="internal" href="user.html" >user</a>/<a class="internal" href="server.html" >server</a> interface either.

<p>As a result, microkernel-based systems are slower, bigger, harder to program, and harder to customize than monolithic <a class="internal" href="kernel.html" >kernel</a>s. The only valid rationale about them is that they encourage some modularity. However, this modularity microkernels enforce on system programmers is of a very <a class="internal" href="low-level.html" >low-level</a> kind, which implies the overhead of (un)marshalling, as well as total lack of consistency or trust between communicating <a class="internal" href="server.html" >server</a>s. In comparison, "monolithic" systems can achieve arbitrary useful modularity with dynamically-loaded <a class="internal" href="kernel.html" >kernel</a> code, allowing automatic enforcement of whatever consistency the system programming languages can express (for instance, strong static typing with <a class="internal" href="module.html" >module</a> scoping in <a class="internal" href="modula-3.html" >Modula-3</a>-programmed <a class="internal" href="spin.html" >SPIN</a> and <a class="internal" href="ml.html" >Standard ML</a>-programmed <a class="internal" href="fox.html" >Fox</a>, or just weak typing with filtered global symbol matching in <a class="internal" href="c_20language.html" >C</a>-programmed <a class="internal" href="linux.html" >Linux</a>).

<p>Thinking that microkernels may enhance computational performance can stem but from a typical myopic analysis: indeed, at every place where functionality is implemented, things look locally simpler and more efficient. Now, if you look at the whole picture, and sum the local effects of microkernel design all over the place, it is obvious that the global effect is complexity and bloat in as much as the design was followed, i.e. at every <a class="internal" href="server.html" >server</a> barrier. For an analogy, take a big heavy beef, chop it into small morsels, wrap those morsels within hygienic plastic bags, and link those bags with strings; whereas each morsel is much smaller than the original beef, the end-result will be heavier than the beef by the weight of the plastic and string, in a ratio inversely proportional to the small size of chops (i.e. the more someone boasts about the local simplicity achieved by his �K, the more global complexity he has actually added w.r.t. similar design w/o �K). Microkernels only generate artificial barriers between functionalities, and any simplicity in <a class="internal" href="server.html" >server</a>s is only the intrinsic simplicity of provided functionality, that is independent from the existence of <a class="internal" href="low-level.html" >low-level</a> barriers around it. Every part of a �K-based design is simpler (than a whole system), of course, because the design has butchered the system into small parts! But if one considers same-functionality overall systems, the only thing �K does is introduce stupid <a class="internal" href="low-level.html" >low-level</a> barriers between services. The services are still there, and their intrinsic complexity isn't reduced: for every small part of a �K-based system, one could find a corresponding, smaller or equal part, in a same-functionality non-�K system, namely the one that implements the same functionality without having to marshall data to cross barriers. 

<p>Microkernels start from the (Right) idea of having modular <a class="internal" href="high-level.html" >high-level</a> system design, and confuse the issue so as to end with the (Wrong) idea of its naive implementation as a <a class="internal" href="low-level.html" >low-level</a> centralized run-time <a class="internal" href="module.html" >module</a> manager, which constitutes a horrible <a class="internal" href="abstraction_20inversion.html" >abstraction inversion</a>. So they have system programmers manually emulate an asynchronous parallel <a class="internal" href="actor.html" >actor</a> model with coarse-<a class="internal" href="grain.html" >grain</a>ed <a class="internal" href="c_20language.html" >C</a>-programmed polling processes, instead of directly using a real fine-<a class="internal" href="grain.html" >grain</a>ed <a class="internal" href="actor.html" >actor</a> language with optimizing compiler (<a class="internal" href="erlang.html" >Erlang</a>, <a class="internal" href="oz.html" >Mozart/Oz</a>, <a class="internal" href="modula-3.html" >Modula-3</a>, some <a class="internal" href="concurrent.html" >concurrent</a> variant of <a class="internal" href="lisp.html" >Lisp</a> or <a class="internal" href="ml.html" >ML</a> or <a class="internal" href="haskell.html" >Haskell</a>, etc.). The discrepancy between the model and its naive and awkward implementation induces lots of overhead, that get worked around with lots of stupid compromises, with a two-level programming system: objects are segregated into a finite set of <a class="internal" href="server.html" >server</a>s and a <a class="internal" href="kernel.html" >kernel</a>, with completely different programming models for combining objects inside a same space and for combining objects not in a same space. Performance gets so bad that most "basic resources" must be statically special-cased in the "microkernel" anyway, and people group as much functionality as they can in every <a class="internal" href="server.html" >server</a> to not pay the price of inter-<a class="internal" href="server.html" >server</a> communication during their interaction. Semantics also becomes very difficult to get right, since <a class="internal" href="low-level.html" >low-level</a> interactions make a hell out of debugging the already complex <a class="internal" href="concurrent.html" >concurrent</a> <a class="internal" href="actor.html" >actor</a> model. In the end, people put the whole of <a class="internal" href="os.html" >OS</a> services in a monolithic "single-<a class="internal" href="server.html" >server</a>", which completely defeats the whole purpose of a microkernel! As a result, everything gets both more complicated and slower! Of course, the very same conclusion holds for <a class="internal" href="kernel.html" >kernel</a>s in general; by pushing the idea of <a class="internal" href="kernel.html" >kernel</a>s to its limits, microkernels only end up proving the whole inadequacy of it.

<p>The only possible justification for a microkernel is not technical. It's political: a microkernel is the only way to allow with any robustness the existence of black-box proprietary third-party binary <a class="internal" href="module.html" >module</a>s that access and provide deep system resources without anyone having to disclose source code. Microkernels are technically the worst possible organization for system code of same functionality, and the fact that the proprietary closed-source development model encourages such horrors accounts for the deep evil behind that model. It has been suggested that a psychological reason behind the <a class="internal" href="abstraction_20inversion.html" >abstraction inversion</a> is that, by a misled tradition, the "<a class="internal" href="operating_20system.html" >Operating System</a>" community stubbornly refuses to mess with language issues (they claim "language independence"), and stick to designing system interfaces for bit-level languages; but we can also track this want of language "independence" to the political issue of proprietary software, since it is what induces the eager clustering of computing into hermetic fields where no one can modify or adapt (proprietary) code from other fields forces people into the paranoid "trust no one, never cooperate: even if you want to, you can't" behavior.

<p>Latest developments in microkernels (<a class="internal" href="l4.html" >L4</a>, <a class="internal" href="xok.html" >Xok</a>) amount to reducing as much as possible the semantics and overhead of the <a class="internal" href="kernel.html" >kernel</a>, and putting everything in either <a class="internal" href="server.html" >server</a>s or system libraries. The logical next step beyond these developments would be to reduce the microkernels to zero, naught, nada, and have everything in "<a class="internal" href="module.html" >module</a>s" that constitute the system, and are <a class="internal" href="high-level.html" >high-level</a> concepts without forcibly any obvious, one-to-one direct correspondence between the <a class="internal" href="high-level.html" >high-level</a> compile-time <a class="internal" href="module.html" >module</a>s limits and <a class="internal" href="low-level.html" >low-level</a> run-time code barriers. Depending on the point of view, this leaves us either with "monolithic" systems, or with systems without a privileged <a class="internal" href="kernel.html" >kernel</a> at all (such as systems built atop the <a class="internal" href="flux.html" >Flux</a> <a class="internal" href="oskit.html" >OSKit</a>). Such is the right way, in our opinion: to provide <a class="internal" href="high-level.html" >high-level</a> modular design, but without any <a class="internal" href="kernel.html" >kernel</a> at all. <a class="internal" href="kernel.html" >Kernel</a>s are but a stubborn straightforward <a class="internal" href="low-level.html" >low-level</a> implementation of <a class="internal" href="module.html" >module</a> management, through a centralized runtime message passing agent. Tunes will provide an optimizing compiler so that local message passing, which is only a <a class="internal" href="low-level.html" >low-level</a> model for application of a function, will be completely inlined.

<p>See also <a class="internal" href="microkernel_20debate.html" >Microkernel Debate</a>.
<hr><p><b>Pages in this topic: </b> <a class="internal" href="amoeba.html" >Amoeba</a> &nbsp; <a class="internal" href="chaos.html" >chaOS</a> &nbsp; <a class="internal" href="chorus.html" >Chorus</a> &nbsp; <a class="internal" href="exokernel.html" >Exokernel</a> &nbsp; <a class="internal" href="hop.html" >hOp</a> &nbsp; <a class="internal" href="knewcleus.html" >Knewcleus</a> &nbsp; <a class="internal" href="l4.html" >L4</a> &nbsp; <a class="internal" href="mach.html" >Mach</a> &nbsp; <a class="internal" href="morphos.html" >MorphOS</a> &nbsp; <a class="internal" href="off.html" >Off</a> &nbsp; <a class="internal" href="openblt.html" >OpenBLT</a> &nbsp; <a class="internal" href="phantom_20os.html" >Phantom OS</a> &nbsp; <a class="internal" href="qnx.html" >QNX</a> &nbsp; <a class="internal" href="rtmk.html" >rtmk</a> &nbsp; <a class="internal" href="spoon.html" >Spoon</a> &nbsp; <a class="internal" href="topsy.html" >Topsy</a> &nbsp; <a class="internal" href="vsta.html" >VSTa</a> &nbsp; <a class="internal" href="vxworks.html" >VxWorks</a> &nbsp; <a class="internal" href="ycx2.html" >YCX2</a> &nbsp; <hr><p><b>Also linked from: </b> <a class="internal" href="abstraction_20inversion.html" >Abstraction Inversion</a> &nbsp; <a class="internal" href="adaos.html" >AdaOS</a> &nbsp; <a class="internal" href="andy_20tanenbaum.html" >Andy Tanenbaum</a> &nbsp; <a class="internal" href="apostle.html" >Apostle</a> &nbsp; <a class="internal" href="io.html" >Io</a> &nbsp; <a class="internal" href="kernel.html" >Kernel</a> &nbsp; <a class="internal" href="microkernel_20debate.html" >Microkernel Debate</a> &nbsp; <a class="internal" href="microkernel-based_20os.html" >Microkernel-based OS</a> &nbsp; <a class="internal" href="ojos.html" >OJOS</a> &nbsp; <a class="internal" href="orthogonal_20persistence.html" >Orthogonal Persistence</a> &nbsp; <a class="internal" href="trotskyite_20tunes.html" >Trotskyite Tunes</a> &nbsp; </DIV></BODY></HTML>